# Intro
I learned a lot of new techniques to make this project work. Much of my project was either copied or adapted from the tile-based tutorial found on the website here: [technologies4me](http://technologies4.me/browse/game-development/tile-based-c2/). In broad strokes, the code uses three classes, `TileMap`, `Character`, and `Sprite`, and their class methods.

The `TileMap Class` works by taking an array of numbers whose values correspond to different tile types, pushing those tiles to a new array, and then by drawing those tiles to the canvas using `for loops`. The `Character Class` works by calculating where the character-object is, where it is trying to move to, and how long it will take to move to the next tile. And finally, the `Sprites Class` handles animations by cycling through arrays of images if the given object contains multiple sprite frames.

# Specifics
## Tile and TileMap Classes
The game map is made up of tile-objects. Each tile object is 16 by 16 pixels, has an x and y coordinate value, has a type value, and has a pointer value – `eventEnter` -- which can be used to trigger other functions. The class `Tile` stores information related to each tile-object instance. Likewise, the `TileMap` class works with the `gameMap()` array to draw each `Tile` object in a certain location on the canvas. Each `TileMap` object instance has the associate properties: a map() array, a map width, a map height, and levels. To draw the map to the canvas, the `TileMap` class uses the `buildMapFromData(d, w, h)` method. This method takes three arguments: a `gameMap()` array, the map width, and the map height. If the product of the map width and the map height do not equal the `gameMap().length` the function returns false and sets the map length to zero. If the first check is passed then two `for loops` iterate through the `gameMap()` array and push a new `Tile` object into the `map()` array. The tile-object type property is determined by each index value of the `gameMap()` array. For example, a value of 0 indicates that that the tile is solid, cannot be walked on, and that its location on the sprite sheet can be found at x: 172 and y:442. The `tiletype{}` object contains a list of different tiles and their properties like sprite location and whether they can be walked on or not.

## Character Class
The `Character` class has eight different properties and five different methods to help calculate where the character-object is on the map, which tile it is trying to move to, if it is possible to move to said tile, which direction the character-object is facing, and how long it will take the character-object to move on to a tile.

Method `placeAt(x,y)` uses the x and y values in the `Character` properties `tileFrom(x,y)` and `tileTo(x,y)`. It centers the character-object on the current tile by adding half the difference between character sprite width or height and the tile width or height to the product of the tile width or height and the x or y coordinate.

Method `processMovement(t)` helps calculate where the character-object is on the canvas. It uses real time, variable `gameTime`, to fill its argument `t`. If the values of `tileFrom(0)` equals `tileTo(0)` and `tileFrom(1)` equals `tileTo(1)` the character is not moving and the function can be exited. If the check however is passed then a new variable, `moveSpeed` is initialized and set to the value of the `delayMove()` property. The `delayMove()` property itself is determined by `tileType` which can be accessed through the `mapTileData.map` object, an object instance of the `TileMap` class. `This.tileFrom(0)` and `this.tileFrom(1)` are passed into the function `toIndex()` which uses them to find an index value within the `mapTileData.map()` array. Once a tile-object has been found within the `mapTileData.map()` array the tile-objects type property is accessed, which is then finally used to access the `floorTypes` property and its numerical value which determines how many milliseconds it takes the character-object to cross the tile-object. If the time the character-object has been moving is longer than or equal to time it takes the character-object to move one tile the placeAt() method places the character-object onto the tile. Otherwise, the character-object is still moving, and its position needs to be recalculated. First, the values of `tileFrom(0)` and `tileFrom(1)` are calculated and then assigned to the `this.position(0)` and `this.position(1)` character class properties. Next, the x and y axis are checked for movement. If movement exists a new variable is initialized, `xDiff` or `yDiff`, and assigned the value of `tileW` divided by `moveSpeed` multiplied by `gameTime` minus value of `this.timeMoved`, or how long the character object has been moving. The value of `xDiff` or `yDiff` is then added or subtracted, depending on where `tileTo()` lies in relation to `tileFrom()`, to the value of `this.position()`. The value of `this.position()` is rounded to help smoothen movement. Finally, the function returns true, which tells other functions which use `processMovement(t)` that the character-object is currently moving.
Method `canMoveTo(x,y)` take the x and y coordinates of the tile the character-object is trying to move to as arguments. First it checks that the tile the character-object is trying to move to is within the map boundaries. If it is, it moves on to check the value of the target tile’s `delayMove` value. If that value is undefined, it is assumed the character-object may not move on to it. This method also works with the `MapObject` class to determine if an object is currently on the target tile and if that object is walk-through-able.

Methods `canMoveUp()` and its other directional counterparts call the `canMoveTo(x,y)` method, and modify the value of `tileFrom()` depending on which direction the character-object is moving. The following switch block takes the `direction` property as an argument and returns the corresponding `canMoveDirection()` function. Similarly, methods `moveLeft()` and its other directional counterparts modify the value of the `tileTo()` property depending on which direction the character-object is moving. Here, the value of variable `gameTime` is passed in as an argument, which is then updated to include how long it takes the character-object to move across a certain tile. The player `direction` property is also updated depending on which direction the player is moving. The following switch block uses direction to determine which `moveDirection(t)` method will be called.

## Sprite Class
The `Sprite` class takes a single argument, data, which will later be filled by an array of objects, if the sprite is to be animated, or a single object. The class includes four properties and a single method to determine if a sprite will be animated, and then either draw the static sprite or loop through the sprite frames. If the length of the array passed in as an argument is longer than one, then a `for loop` iterates through the `Sprite` class properties. If no duration value has been defined, it is automatically set to 100 milliseconds. If it does have a duration value, the object instance duration value is updated to reflect that value. If the sprite-object’s loop value is defined, that value is used to update the sprite-object-instance’s loop value property. Finally, the variable `this.frames` is assigned a value of what is passed in as an argument, data, when a new `Sprite(data)` object instance is created.

Method `draw(t, x, y)` takes three arguments when called. `T` is the amount of currently elapsed `gameTime`, `x`, and `y` are the sprite-object’s calculated x and y coordinate position. Method begins by initializing a new variable, `frameIdx` and assigning it a value of 0 as the first frame to be played is the first sprite within the passed-in array. Next, the method uses an `if statement` to check that the sprite-object does not loop, is animated, and if the amount of elapsed time is greater than the value of the `duration` property. If it evaluates to true, the last frame in the passed-in array is drawn. If it evaluates to false, the sprite-object is animated and it does loop. The value of `t` is set to `t % this.duration` to prevent the value of `t` from increasing beyond the value of `this.duration`. Next variable `totalD` is initialized and given a value of 0. This variable is used to store at what time each frame ends. A `for loop` then iterates through the passed-in array, `frames`. The value of `totalD` is increased by each `frames duration` property. Before the `for loop` can be exited the value of `t` must be less than or equal to the value of `totalD`. When this `if loop` evaluates to true, it means the correct frame has been calculated and the loop can be exited. Finally, the sprite-frame can be drawn to the canvas. Each new frame is drawn to the canvas using its calculated x and y coordinate positions, its width and height, and any offset values it might have.

## Viewport Object
The viewport object is used to center the camera on the player-object and to help the program draw only what is visible on screen. All tiles which fall outside of the viewport boundaries are culled, which frees up resources.

To center the camera on the character, the viewport uses the following properties: `screen()`, `startTile()`, `endTile()`, `offset()` and `update(px, py)`. To find the center tile, the desired viewport center coordinates are passed in as arguments, `px` and `py` into the `update(px, py)` function. A new variable, `tile` is then initialized and given the value of `px / tileW` and `py / tileH`. The `startTile()` is the left-most visible tile, and its position is calculated by finding the max number of tiles which fit within half the screen width and then subtracting that amount from the position value of the center tile. Finding the end tile follows a similar process, but instead of subtraction, addition is used. After finding the `startTile()` position and `endTile()` position, the program checks that these tiles fall within the visible portion of the map. If they fall outside of the map boundaries, their values are set to 0.

## window.onload Function
Once the webpage has finished loading, a few things need to happen before the game can be drawn to the canvas. First the variable `ctx` is initialized and assigned a context of `2d`. `Window.addEventListener` functions are used to check for when the arrow keys or space keys are pressed down. All keys are given an initial value of false as it is assumed they will not be pressed at first. The `viewport.screen` property is assigned the canvas width and height as values. The `mapTileData.buildMapFromData(currentMap(0), mapW, mapH)` method is called, and a few tiles are given an event trigger with the `mapTileData.map.eventEnter` property.

## DrawGame Function
Finally, the game can be drawn to the canvas. After a few checks that the tile set has loaded properly, and that the program has the proper context the variables which handle time can be initialized and assigned a value. The variables `sec` `curentFrameTime`, and `timeElapsed` are all used by the `Character` class to calculate the player-object’s position on the canvas.

A block of `if` statements check if an arrow key is currently being pressed and, if true, call the `player.canMoveTo` and `player.moveDirection` functions which correspond to the pressed key. The `viewport.update(px, py)` function is called and the player-object’s position is passed in as an argument, which centers the camera on the player-object. A black rectangle is also drawn to the screen after each frame to prevent moving objects from ‘streaking’.
After, nestled `for loops` iterate through the `mapTileData’s` map property, which is an array of `Tile` objects. The for loops continue iterating and drawing, for as long as their value is less than or equal to the length of the viewport width and the length of the viewport height values.

## Things That Didn’t Work
There were many things I attempted, but unfortunately could not finish before the deadline. Among the most noticeable absences, are any pieces of my portfolio which I was hoping to use this program to display. I attempted to create a function, `interatWith()` which would handle the player-object’s interactions with special objects like signs or books. While I did kind of get this function to work, it is very buggy. The spacebar, must be held down while the player-object enters a specific square, and once it is activated it creates a loop which cannot be exited – the player-object walks away from then back into the trigger square without any input from arrow keys. I think this bug happens as there is no exit condition for the `if` statement used to check if the spacebar is being pressed. Once it evaluates to true, it remains true.

I wanted to use a JSON object to store all of my map arrays. With a lot of help from my professor, I was able to get a version of this to work. However, I was unable to get it to work with a couple other functions of mine, like the one which handles entering a building.

Entering the building works but exiting it does not work. In general, I need a better system of marking which tiles trigger events. As it works now, a tile-object’s index value is used to mark which tiles trigger functions. This could lead to problems, especially with the addition of more maps, as index values are not unique to each different map. This could lead to events triggering where they are not supposed to.
And finally, I wanted to use my own art assets for all the different tiles and sprites. I tried creating some art assets early on, but it quickly dawned on me that I needed to spend more time working on my code than drawing. The art assets I used are all used with permission, but it would be nice to one day use my own assets.
